<#
Initial version: arnoud.van.voorst@hp.com
Aldea 945952: R85379 AD account provisioning script
#>

<#
This script is part of a bundle of three scripts that run as scheduled jobs (Auto-UAA.ps1, Auto-UAA-messaging.ps1 and Auto-UAA-reprorting.ps1)
    Auto-UAA.ps1 is the script that read an input file with users and creates AD-accounts.
    Auto-UAA-messaging.ps1 is the script that creates mailboxes, enables Lync and set the password.
    Auto-UAA-reporting.ps1 generates a report of the accounts created yesterday

Txt files in the process and complete folders are use as data transfer between the scripts.
    <samaccountname>.mail.txt -> account waiting for mailbox creation
    <samaccountname>.lync.txt -> account waiting for enabling Lync
    <samaccountname>.enable.txt -> account waiting for password and enabling

Auto-UAA.cfg is a comma separated file that contains variables that are used in all scripts.
#>

<# History
2016-12-27 v3.1   KHi  Added processing steps Rebind and Unbind.
2016-10-24 v3.0   KHi  RfC 1244719 - Wait of the existence of the manager before sending out the message to the manager.
2014-11-26 V2.6   AVV  On request of Plamen (meeting 26-11) do not export report when it is empty
2014-11-06 v2.5   KHi  Added timestamp to the report file (_yyyy-MM-dd-HHmm).
                       Moved the send message to manager to the Auto-UAA-message controler.
2014-11-12 v2.4.2 AVV  Fixed "timestamp always 0000" bug, removed the .date part from: $reportDate = (Get-Date).Date
2014-11-04 v2.4   AVV  VDO users check changed to "^NA", original match "^88" - no special email to UAA team anymore.
2014-08-08 v2.3   KHi  Added logging.
                       Changed the mail subject to 'ON HOLD VDI' in case the EmployeeID starts with 88.
                       Report only on new accounts that have an employeeID (and use an -LDAPFilter instead of -Filter).
2014-08-05 v2.2.2 AVV  Fixed logging (email sendto:).
                       Added run only from scheduler test (-force).
2014-07-25 v2.2.1 AVV  Fixed email send issue.
2014-07-23 v2.2   AVV  If known now the email is send to the manager otherwise to the UAA team.
                       Added .Net email solution instead of the standard PowerShell cmdlet to support replyto.
                       (replyto is needed to support the HP email address while sending with a demb server).
2014-07-16 v2.1   AVV  Some bug fixes and added manager information (manager email and manager display name).
                       Save a compete report in the completed folder too.
2014-07-10 v2.0   AVV  Now the report includes all the new users the last 24hours (autogenerated and generated by UAA team).
                       Only autogenerated accounts will get a password and ends in a email.
2014-07-10 v2.0   AVV  Added manager to emails.
           v1.0   AVV  initial script.
#>

#run only from scheduler
Param ([Switch]$Force)

#define logfile with the name as the script
$logfile = $MyInvocation.MyCommand.Definition -replace(".ps1$",".log")
#create the logfile if the file does not exitst else write todays first empty line as batch seperator
If(!(test-path $logFile)){New-Item $logFile -ItemType file >$null}
else { Add-Content -path $logFile -Value "" }
Add-Content -Path $logFile -value $((Get-Date -Format "yyyy-MM-dd HH:mm:ss ") + "Script started (" + $env:USERNAME + ")")

#-------------------------------------------------------------
#functions
#-------------------------------------------------------------
function Write-Log([string]$LogMessage)
{
    $msg = "{0} {1}" -f (get-date -Format "yyyy-MM-dd HH:mm:ss"),$LogMessage
    Add-Content -Path $logFile -Value $msg
    Write-Debug $msg
}

#This function write the error to the logfile and exit the script
function Error-Break([string]$ErrorMessage)
{
    Write-Log($ErrorMessage)
    Write-Log("Script stopped")
    Exit
}

#run only from scheduler, exit when started manually
if(!$force.IsPresent)
    {
        Write-Error "Due to interaction with other processes this script must only run at the scheduled times. DO NEVER RUN THIS SCRIPT MANUALLY!"
        Error-Break ("Script manually started by: {0}" -f $env:USERNAME )
    }

#set this only in test/debug mode
#$DebugPreference = "continue"

#-------------------------------------------------------------
#parameters
#-------------------------------------------------------------
#variables in cfg file (name = example)
#$inputFileName = "new_users.csv"
#$inputFilePath = "D:\Scripts\Auto-UAA"
#$succesFilePath = "D:\Scripts\Auto-UAA\Idm_new_users_Archive"
#$errorFilePath = "D:\Scripts\Auto-UAA\Idm_new_users_Error_Archive"
#$emailErrorsTo = "arnoud.van.voorst@hp.com"
#$emailErrorsFrom = "arnoud.van.voorst@hp.com"

##read (above) variables from cfg file and cleanup the path variables (if needed add backslash)
Import-CSV ($PSScriptRoot + "\Auto-UAA.cfg") -Delimiter ";" | ForEach-Object { New-Variable -Name $_.Variablename -Value $_.Value -Force -Scope Script }
If ($errorFilePath -notmatch "\\$")  { $errorFilePath += "\" }
If ($inputFilePath -notmatch "\\$")  { $inputFilePath += "\" }
If ($reportFilePath -notmatch "\\$") { $reportFilePath += "\" }
If ($succesFilePath -notmatch "\\$") { $succesFilePath += "\" }

$processPath = $PSScriptRoot + "\process\"
$completedPath = $PSScriptRoot + "\completed\"

#create the process and completed folder if not exist already
If(!(test-path $processPath)){New-Item $processPath -ItemType directory >$null}
If(!(test-path $completedPath)){New-Item $completedPath -ItemType directory >$null}

#2014-11-12 v2.4.2 AVV - changed to full date instead of datepart only
#$reportDate = (Get-Date).Date
$reportDate = Get-Date

#region Process *.bind.txt

#These files are coming from the rebind process where the account need to be unbound first and in the second run needs to be reported again.

Get-ChildItem -Path "$ProcessPath\*.Bind.txt" | ForEach-Object { Rename-Item -Path $_.FullName -NewName ($_.FullName -replace '.Bind.txt','.Report.txt') }

#endregion

#region Process *.Rebind.txt

#Copy the files to be processed for the next run as to be reported
Get-ChildItem -Path "$ProcessPath\*.Rebind.txt" | ForEach-Object { Copy-Item -Path $_.FullName -Destination ($_.FullName -replace '.Rebind.txt','.Bind.txt') }

#Rename the files to be unbound
Get-ChildItem -Path "$ProcessPath\*.Rebind.txt" | ForEach-Object { Rename-Item -Path $_.FullName -NewName ($_.FullName -replace '.Rebind.txt','.Unbind.txt') }

#endregion

#region Process *.Unbind.txt

#Read the files/user schedule for reporting and trim the Unbind.txt extention (usage of regEx)
$ScheduledToUnbind = Get-ChildItem ($ProcessPath + "\*.Unbind.txt") | ForEach-Object { $_.Name -Replace(".Unbind.txt$","") }

Write-Debug ("Scheduled to Unbind: {0}" -f [string]$ScheduledToUnbind)

$Report = @()

if ($ScheduledToUnbind -ne $null -or $ScheduledToUnbind.Count -gt 0)
{
    Write-Debug ([string]$ScheduledToUnbind)
    Write-Log("Number of user to report on: {0}" -f $ScheduledToUnbind.Count)

    foreach($User in $ScheduledToUnbind)
    {
        Try
        {
            #Get the AD data from the user
            $ADUser = Get-ADUser $User -Properties EmployeeID

            #add user to report
            $Report += $ADUser | Select-Object employeeID

            Remove-Item -Path ("{0}\{1}.Unbind.txt" -f $ProcessPath, ($ADUser.sAMAccountName)) -Force
        }
        Catch
        {
            Write-Debug $Error[0]
            Write-Log("Error found in user object ({0}): {1}" -f $User.sAMAccountName, $Error[0])
        }
    }#foreach

    #Before saving the report, remove passwords and manager etc. first
    #only add EmployeeID,mail,SamAccountName,UserPrincipalName,telephoneNumber,mobile,facsimileTelephonenumber,DistinguishedName to the report
    $Report |
        Select-Object -Property EmployeeID, mail, SamAccountName, UserPrincipalName, telephoneNumber, mobile, facsimileTelephonenumber, DistinguishedName |
        Export-Csv ("{0}AD_upload_{1}.csv" -f $ReportFilePath,(Get-Date($ReportDate) -Format "yyyy-MM-dd-HHmm")) -Delimiter ";" -NoTypeInformation -Append

    if (Test-Path ("{0}AD_upload_{1}.csv" -f $ReportFilePath,(Get-Date($ReportDate) -Format "yyyy-MM-dd-HHmm")))
    {
        Write-Log("Export written to {0}" -f ("{0}AD_upload_{1}.csv" -f $ReportFilePath,(Get-Date($ReportDate) -Format "yyyy-MM-dd-HHmm")))
    }
    else
    {
        Write-Log("Not able to export to {0}" -f ("{0}AD_upload_{1}.csv" -f $ReportFilePath,(Get-Date($ReportDate) -Format "yyyy-MM-dd-HHmm")))
    }

    #save full report in script share
    $Report | Select-Object employeeID, mail, sAMAccountName, userPrincipalName, telephoneNumber, mobile, facsimileTelephonenumber,
        distinguishedName, manager, managerDisplayname, managerEmail, Password |
        Export-Csv ("{0}AD_upload_{1}.csv" -f $CompletedPath,(Get-Date($ReportDate) -Format "yyyy-MM-dd-HHmm")) -Delimiter ";" -NoTypeInformation -Append
}
else
{
    Write-Log("No user to unbind")
}

#endregion

#region Process *.Report.txt

# read the files/user schedule for reporting and trim the report.txt extention (usage of regEx)
$ScheduledToReport = Get-ChildItem ($processPath + "\*.report.txt") | ForEach-Object { $_.Name -Replace(".report.txt$","") }

Write-Debug ("Scheduled to report: {0}" -f [string]$ScheduledToReport)

$Report = @()

if ($ScheduledToReport -ne $null -or $ScheduledToReport.Count -gt 0)
{
    Write-Debug ([string]$ScheduledToReport)
    Write-Log("Number of user to report on: {0}" -f $ScheduledToReport.Count)
}
else
{
    Write-Log("No user to report on")
    break
}

foreach($User in $ScheduledToReport)
{
    Try
    {
        #Get the AD data from the user
        $ADUser = Get-ADUser $User -Properties *

        #Get the password from the <completedpath>\<samaccountname>.manager.txt
        #read password form last line in the user completed file (regex used to check and strip the datepart)
        $Password = $null
        $Match = "^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} Password: "        $Password = (Get-Content ("{0}{1}.report.txt" -f $completedPath, $ADUser.sAMAccountName) | Where-Object {$_ -match $Match} |            Select-Object -Last 1) -replace($Match)        Add-Member -Force -InputObject $ADUser -NotePropertyName Password -NotePropertyValue $Password

        Write-Debug (Out-String -InputObject $ADUser)

        #set manager properties to unknow and try to find these properties afterwards
        Add-Member -Force -InputObject $ADUser -NotePropertyname ManagerEmail -NotePropertyValue "<unknown>"
        Add-Member -Force -InputObject $ADUser -NotePropertyname ManagerDisplayname -NotePropertyValue "<unknown>"

        #get email address of manager
        If(($ADUser.manager -ne "") -and ($ADUser.manager -ne $null))
            {
                $ADUser.ManagerEmail = (Get-ADUser -LDAPFilter "(DistinguishedName=$($ADUser.manager))" -Properties mail).mail
                $ADUser.ManagerDisplayName = (Get-ADUser -LDAPFilter "(DistinguishedName=$($ADUser.manager))" -Properties displayName).displayName
            }

        #add user to report (autogererated or manually created
        $Report += $ADUser | Select-Object employeeID, mail, sAMAccountName, userPrincipalName, telephoneNumber, mobile, facsimileTelephonenumber,
            distinguishedName, manager, managerDisplayname, managerEmail, Password

        #Remove the report file from the process folder instead of moving it (RfC 1244719)
        Remove-Item -Path ("{0}\{1}.report.txt" -f $processPath, ($ADUser.sAMAccountName)) -Force
    }
    Catch
    {
        Write-Debug $Error[0]
        Write-Log("Error found in user object ({0}): {1}" -f $User.sAMAccountName, $Error[0])
    }
}#foreach

#Before saving the report, remove passwords and manager etc. first
#only add EmployeeID,mail,SamAccountName,UserPrincipalName,telephoneNumber,mobile,facsimileTelephonenumber,DistinguishedName to the report
$Report |
    Select-Object -Property EmployeeID, mail, SamAccountName, UserPrincipalName, telephoneNumber, mobile, facsimileTelephonenumber, DistinguishedName |
    Export-Csv ("{0}AD_upload_{1}.csv" -f $reportFilePath,(Get-Date($Reportdate) -Format "yyyy-MM-dd-HHmm")) -Delimiter ";" -NoTypeInformation -Append

if (Test-Path ("{0}AD_upload_{1}.csv" -f $reportFilePath,(Get-Date($Reportdate) -Format "yyyy-MM-dd-HHmm")))
{
    Write-Log("Export written to {0}" -f ("{0}AD_upload_{1}.csv" -f $reportFilePath,(Get-Date($Reportdate) -Format "yyyy-MM-dd-HHmm")))
}
else
{
    Write-Log("Not able to export to {0}" -f ("{0}AD_upload_{1}.csv" -f $reportFilePath,(Get-Date($Reportdate) -Format "yyyy-MM-dd-HHmm")))
}

#save full report in script share
# KHi: 2014-11-05 Added timestamp
$Report | Export-Csv ("{0}AD_upload_{1}.csv" -f $completedPath,(Get-Date($Reportdate) -Format "yyyy-MM-dd-HHmm")) -Delimiter ";" -NoTypeInformation -Append

#endregion